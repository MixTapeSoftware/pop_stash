# Phase 1.5: Projects Foundation — Implementation Steps

Based on `PROJECT_PLAN.md`. Execute in order.

---

## Current State

- Phase 1 complete: MCP server running with `ping` tool
- Router already accepts `/mcp/:project_id` (passes through without validation)
- No database yet
- No project validation
- Tools don't receive project context

---

## Overview

This phase adds PostgreSQL with pgvector and implements project isolation. Every MCP request will be scoped to a validated project.

```
┌───────────────────────────────────────────────────────────────────────────────┐
│                            PopStash Server                                     │
│                        (http://localhost:4001)                                 │
├───────────────────────────────────────────────────────────────────────────────┤
│                                                                                │
│  ┌─────────────────────┐  ┌─────────────────────┐  ┌─────────────────────┐    │
│  │  Project: foo       │  │  Project: bar       │  │  Project: baz       │    │
│  │  /mcp/<uuid-1>      │  │  /mcp/<uuid-2>      │  │  /mcp/<uuid-3>      │    │
│  └─────────────────────┘  └─────────────────────┘  └─────────────────────┘    │
│                                                                                │
│                   Data is completely isolated per project                      │
└───────────────────────────────────────────────────────────────────────────────┘
```

---

## Step 1: Add Ecto Dependencies

Update `mix.exs`:

```elixir
defp deps do
  [
    # Runtime
    {:bandit, "~> 1.5"},
    {:jason, "~> 1.4"},
    {:plug, "~> 1.16"},
    {:telemetry, "~> 1.2"},
    
    # Database
    {:ecto_sql, "~> 3.11"},
    {:postgrex, "~> 0.18"},

    # Dev/test
    {:credo, "~> 1.7", only: [:dev, :test], runtime: false},
    {:mimic, "~> 1.10", only: :test},
    {:sobelow, "~> 0.13", only: [:dev, :test], runtime: false},
    {:tidewave, "~> 0.1", only: :dev}
  ]
end
```

**Run:** `mix deps.get`

---

## Step 2: Create Docker Compose for PostgreSQL

Create `docker-compose.yml` at project root:

```yaml
services:
  db:
    image: pgvector/pgvector:pg16
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: pop_stash_dev
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

volumes:
  pgdata:
```

**Run:** `docker-compose up -d`

---

## Step 3: Create Ecto Repo

Create `lib/pop_stash/repo.ex`:

```elixir
defmodule PopStash.Repo do
  use Ecto.Repo,
    otp_app: :pop_stash,
    adapter: Ecto.Adapters.Postgres

  @doc """
  Migration defaults ensure all tables use:
  - UUID primary keys (generated by Postgres)
  - UTC datetime with microseconds for timestamps
  """
  def default_options(:migration) do
    [
      primary_key: [type: :binary_id],
      timestamps: [type: :utc_datetime_usec]
    ]
  end
end
```

---

## Step 4: Update Configuration

### config/config.exs

```elixir
import Config

config :pop_stash,
  mcp_port: 4001,
  mcp_protocol_version: "2025-03-26",
  ecto_repos: [PopStash.Repo]

import_config "#{config_env()}.exs"
```

### config/dev.exs

```elixir
import Config

config :pop_stash, PopStash.Repo,
  database: "pop_stash_dev",
  username: "postgres",
  password: "postgres",
  hostname: "localhost",
  port: 5432,
  pool_size: 10
```

### config/test.exs

```elixir
import Config

config :pop_stash,
  start_server: false

config :pop_stash, PopStash.Repo,
  database: "pop_stash_test#{System.get_env("MIX_TEST_PARTITION")}",
  username: "postgres",
  password: "postgres",
  hostname: "localhost",
  port: 5432,
  pool: Ecto.Adapters.SQL.Sandbox

config :logger, level: :warning
```

### config/prod.exs

```elixir
import Config

config :pop_stash, PopStash.Repo,
  url: {:system, "DATABASE_URL"},
  pool_size: String.to_integer(System.get_env("POOL_SIZE") || "10")
```

---

## Step 5: Update Application Supervisor

Update `lib/pop_stash/application.ex`:

```elixir
defmodule PopStash.Application do
  use Application

  @impl true
  def start(_type, _args) do
    children = [
      # Start the Ecto repository
      PopStash.Repo
    ]

    # Add HTTP server in non-test environments
    children =
      if Application.get_env(:pop_stash, :start_server, true) do
        port = Application.get_env(:pop_stash, :mcp_port, 4001)
        children ++ [{Bandit, plug: PopStash.MCP.Router, port: port}]
      else
        children
      end

    Supervisor.start_link(children, strategy: :one_for_one, name: PopStash.Supervisor)
  end
end
```

---

## Step 6: Create Base Schema Module

Create `lib/pop_stash/schema.ex`:

```elixir
defmodule PopStash.Schema do
  @moduledoc false
  defmacro __using__(_) do
    quote do
      use Ecto.Schema

      # We use UUIDs everywhere in order to make model ID
      # collisions almost impossible (e.g. save User.id over
      # Token.id by mistake)
      # A side bonus is that our internal IDs will look
      # different than most external IDs (e.g. Wrike IDs),
      # which is nice when visually analyzing db records
      @primary_key {:id, :binary_id, autogenerate: true}
      @foreign_key_type :binary_id

      @timestamps_opts [type: :utc_datetime_usec]
    end
  end
end
```

---

## Step 7: Create Projects Schema

Create `lib/pop_stash/projects/project.ex`:

```elixir
defmodule PopStash.Projects.Project do
  use PopStash.Schema
  import Ecto.Changeset

  schema "projects" do
    field :name, :string
    field :description, :string
    field :metadata, :map, default: %{}

    timestamps()
  end

  @doc false
  def changeset(project, attrs) do
    project
    |> cast(attrs, [:name, :description, :metadata])
    |> validate_required([:name])
    |> validate_length(:name, min: 1, max: 255)
  end
end
```

---

## Step 8: Create Projects Context

Create `lib/pop_stash/projects.ex`:

```elixir
defmodule PopStash.Projects do
  @moduledoc """
  Context for managing projects.
  
  Projects are the top-level isolation boundary. Each project has its own
  agents, stashes, insights, decisions, and locks.
  """

  import Ecto.Query
  alias PopStash.Repo
  alias PopStash.Projects.Project

  @doc """
  Gets a project by ID.
  
  Returns `{:ok, project}` or `{:error, :not_found}`.
  """
  def get(id) when is_binary(id) do
    case Repo.get(Project, id) do
      nil -> {:error, :not_found}
      project -> {:ok, project}
    end
  end

  @doc """
  Gets a project by ID, raising if not found.
  """
  def get!(id) when is_binary(id) do
    Repo.get!(Project, id)
  end

  @doc """
  Creates a new project.
  
  ## Options
  
    * `:description` - Optional description
    * `:metadata` - Optional metadata map
  """
  def create(name, opts \\ []) do
    attrs = %{
      name: name,
      description: Keyword.get(opts, :description),
      metadata: Keyword.get(opts, :metadata, %{})
    }

    %Project{}
    |> Project.changeset(attrs)
    |> Repo.insert()
  end

  @doc """
  Lists all projects, ordered by creation date (newest first).
  """
  def list do
    Project
    |> order_by([p], desc: p.inserted_at)
    |> Repo.all()
  end

  @doc """
  Deletes a project and all associated data.
  
  Returns `{:ok, project}` or `{:error, :not_found}`.
  """
  def delete(id) when is_binary(id) do
    case get(id) do
      {:ok, project} -> Repo.delete(project)
      error -> error
    end
  end

  @doc """
  Checks if a project exists.
  """
  def exists?(id) when is_binary(id) do
    Project
    |> where([p], p.id == ^id)
    |> Repo.exists?()
  end
end
```

---

## Step 8: Create Migration

**Run:** `mix ecto.gen.migration create_projects`

Edit the generated migration file `priv/repo/migrations/YYYYMMDDHHMMSS_create_projects.exs`:

```elixir
defmodule PopStash.Repo.Migrations.CreateProjects do
  use Ecto.Migration

  def change do
    # Enable pgvector extension (will be used later, but set up now)
    execute "CREATE EXTENSION IF NOT EXISTS vector", "DROP EXTENSION IF EXISTS vector"

    create table(:projects) do
      add :name, :string, null: false
      add :description, :text
      add :metadata, :map, default: %{}

      timestamps()
    end

    create index(:projects, [:name])
  end
end
```

**Run:**

```bash
mix ecto.create
mix ecto.migrate
```

---

## Step 9: Update Router with Project Validation

Update `lib/pop_stash/mcp/router.ex`:

```elixir
defmodule PopStash.MCP.Router do
  @moduledoc """
  HTTP router for MCP server.

  - `POST /mcp/:project_id` — JSON-RPC endpoint, scoped to project
  - `GET /` — Info page

  Localhost-only for security.
  """

  use Plug.Router
  require Logger

  plug(:match)
  plug(:check_localhost)
  plug(Plug.Parsers, parsers: [:json], pass: ["application/json"], json_decoder: Jason)
  plug(:dispatch)

  # Main MCP endpoint — project_id required and validated
  post "/mcp/:project_id" do
    project_id = conn.path_params["project_id"]

    case PopStash.Projects.get(project_id) do
      {:ok, project} ->
        case PopStash.MCP.Server.handle_message(conn.body_params, project) do
          {:ok, :notification} -> send_resp(conn, 204, "")
          {:ok, response} -> json(conn, 200, response)
          {:error, response} -> json(conn, 200, response)
        end

      {:error, :not_found} ->
        Logger.warning("Request for unknown project: #{project_id}")
        error_response = %{
          jsonrpc: "2.0",
          id: conn.body_params["id"],
          error: %{
            code: -32_001,
            message: "Project not found: #{project_id}",
            data: %{
              hint: "Create a project with: mix pop_stash.project.new \"Your Project Name\""
            }
          }
        }
        json(conn, 404, error_response)
    end
  end

  get "/" do
    tools = PopStash.MCP.Server.tools()
    projects = PopStash.Projects.list()
    port = Application.get_env(:pop_stash, :mcp_port, 4001)

    projects_html = if Enum.empty?(projects) do
      "<p><em>No projects yet. Create one with <code>mix pop_stash.project.new \"My Project\"</code></em></p>"
    else
      "<ul>" <> Enum.map_join(projects, fn p ->
        "<li><code>#{p.id}</code> — #{p.name}</li>"
      end) <> "</ul>"
    end

    html = """
    <!DOCTYPE html>
    <html>
    <head><title>PopStash MCP</title>
    <style>body{font-family:system-ui;max-width:700px;margin:40px auto;padding:0 20px}
    code{background:#f4f4f4;padding:2px 6px;border-radius:3px}
    pre{background:#f4f4f4;padding:12px;border-radius:4px;overflow-x:auto}
    .note{background:#fffbeb;border:1px solid #f59e0b;padding:12px;border-radius:4px;margin:12px 0}</style>
    </head>
    <body>
    <h1>PopStash MCP Server</h1>
    <p>POST JSON-RPC 2.0 to <code>/mcp/:project_id</code></p>

    <div class="note">
      <strong>Project ID Required:</strong> Each workspace needs its own project ID in the URL.
      <br>Create one with: <code>mix pop_stash.project.new "My Project"</code>
    </div>

    <h2>Projects (#{length(projects)})</h2>
    #{projects_html}

    <h2>Tools (#{length(tools)})</h2>
    <ul>#{Enum.map_join(tools, fn t -> "<li><b>#{t.name}</b> — #{t.description}</li>" end)}</ul>

    <h2>Claude Code Setup</h2>
    <p>Add to your workspace <code>.claude/mcp_servers.json</code>:</p>
    <pre>{
      "pop_stash": {
        "url": "http://localhost:#{port}/mcp/YOUR_PROJECT_ID"
      }
    }</pre>
    </body></html>
    """

    conn |> put_resp_content_type("text/html") |> send_resp(200, html)
  end

  match(_, do: send_resp(conn, 404, "Not found"))

  ## Security

  defp check_localhost(conn, _opts) do
    if localhost?(conn.remote_ip) do
      conn
    else
      Logger.warning("Rejected non-localhost request from #{:inet.ntoa(conn.remote_ip)}")
      conn |> send_resp(403, "Localhost only") |> halt()
    end
  end

  defp localhost?({127, _, _, _}), do: true
  defp localhost?({0, 0, 0, 0, 0, 0, 0, 1}), do: true
  defp localhost?(_), do: false

  ## Helpers

  defp json(conn, status, data) do
    conn |> put_resp_content_type("application/json") |> send_resp(status, Jason.encode!(data))
  end
end
```

---

## Step 10: Update Server to Accept Project Struct

Update `lib/pop_stash/mcp/server.ex` to accept the project struct instead of just the ID:

```elixir
defmodule PopStash.MCP.Server do
  @moduledoc """
  MCP server implementing JSON-RPC 2.0.

  Tool modules implement a `tools/0` callback returning a list of tool definitions.
  Each definition is a map with `:name`, `:description`, `:inputSchema`, and `:callback`.
  """

  require Logger
  
  alias PopStash.Projects.Project

  @tool_modules [
    PopStash.MCP.Tools.Ping
  ]

  @type message :: map()
  @type response :: map()

  ## Public API

  @doc "Returns available tools (without callbacks, safe for JSON serialization)."
  @spec tools() :: [map()]
  def tools do
    @tool_modules
    |> Enum.flat_map(& &1.tools())
    |> Enum.map(&Map.drop(&1, [:callback]))
  end

  @doc """
  Handles a JSON-RPC 2.0 message.

  Returns `{:ok, response}`, `{:error, response}`, or `{:ok, :notification}`.
  The project struct is passed from the router after validation.
  """
  @spec handle_message(message(), Project.t()) :: {:ok, response() | :notification} | {:error, response()}
  def handle_message(message, %Project{} = project) do
    start_time = System.monotonic_time()

    result =
      with {:ok, msg} <- validate_jsonrpc(message) do
        route(msg, project)
      end

    emit_telemetry(message, result, start_time, project.id)
    result
  end

  ## Routing
  # All routes receive project for current/future use

  defp route(%{"method" => "ping", "id" => id}, _project) do
    {:ok, success(id, %{})}
  end

  defp route(%{"method" => "initialize", "id" => id, "params" => params}, project) do
    version = protocol_version()

    case validate_protocol_version(params["protocolVersion"]) do
      :ok ->
        {:ok,
         success(id, %{
           protocolVersion: version,
           capabilities: %{tools: %{listChanged: false}},
           serverInfo: %{name: "PopStash", version: app_version()},
           projectId: project.id,
           projectName: project.name,
           tools: tools()
         })}

      {:error, reason} ->
        {:error, error(id, -32_602, reason)}
    end
  end

  defp route(%{"method" => "tools/list", "id" => id}, _project) do
    {:ok, success(id, %{tools: tools()})}
  end

  defp route(%{"method" => "tools/call", "id" => id, "params" => params}, project) do
    call_tool(id, params, project)
  end

  defp route(%{"method" => method, "id" => id}, _project) do
    {:error, error(id, -32_601, "Method not found: #{method}")}
  end

  defp route(%{"method" => _method}, _project) do
    {:ok, :notification}
  end

  ## Tool Dispatch

  defp call_tool(id, %{"name" => name, "arguments" => args}, project) do
    case find_tool(name) do
      {:ok, callback} -> execute_tool(id, name, callback, args, project)
      :error -> {:error, error(id, -32_601, "Unknown tool: #{name}")}
    end
  end

  defp call_tool(id, _, _project) do
    {:error, error(id, -32_602, "Missing 'name' or 'arguments'")}
  end

  defp find_tool(name) do
    @tool_modules
    |> Enum.flat_map(& &1.tools())
    |> Enum.find(&(&1.name == name))
    |> case do
      %{callback: cb} -> {:ok, cb}
      nil -> :error
    end
  end

  defp execute_tool(id, name, callback, args, project) do
    result =
      try do
        # Tool callbacks receive (args, project)
        # For backward compatibility, check callback arity
        case Function.info(callback, :arity) do
          {:arity, 1} -> callback.(args)
          {:arity, 2} -> callback.(args, project)
        end
      catch
        kind, reason ->
          Logger.error("Tool #{name} crashed: #{Exception.format(kind, reason, __STACKTRACE__)}")
          {:error, "Tool execution failed"}
      end

    case result do
      {:ok, text} when is_binary(text) ->
        {:ok, success(id, %{content: [%{type: "text", text: text}]})}

      {:ok, data} when is_map(data) ->
        {:ok, success(id, data)}

      {:error, msg} when is_binary(msg) ->
        {:ok, success(id, %{content: [%{type: "text", text: msg}], isError: true})}

      other ->
        Logger.warning("Tool #{name} returned invalid result: #{inspect(other)}")

        {:ok,
         success(id, %{content: [%{type: "text", text: "Invalid tool response"}], isError: true})}
    end
  end

  ## Validation

  defp validate_jsonrpc(%{"jsonrpc" => "2.0", "method" => m} = msg) when is_binary(m) do
    {:ok, msg}
  end

  defp validate_jsonrpc(_) do
    {:error, error(nil, -32_600, "Invalid JSON-RPC 2.0 request")}
  end

  # Protocol versions are date-formatted strings. Lexicographic comparison works.
  defp validate_protocol_version(nil), do: {:error, "protocolVersion required"}

  defp validate_protocol_version(v) when is_binary(v) do
    if v >= protocol_version(), do: :ok, else: {:error, "Protocol version #{v} not supported"}
  end

  defp validate_protocol_version(_), do: {:error, "protocolVersion must be a string"}

  ## Response Builders

  defp success(id, result), do: %{jsonrpc: "2.0", id: id, result: result}

  defp error(id, code, message),
    do: %{jsonrpc: "2.0", id: id, error: %{code: code, message: message}}

  ## Config

  defp protocol_version, do: Application.get_env(:pop_stash, :mcp_protocol_version, "2025-03-26")

  defp app_version, do: Application.spec(:pop_stash, :vsn) |> to_string()

  ## Telemetry

  defp emit_telemetry(message, result, start_time, project_id) do
    :telemetry.execute(
      [:pop_stash, :mcp, :request],
      %{duration: System.monotonic_time() - start_time},
      %{
        method: message["method"],
        tool: get_in(message, ["params", "name"]),
        project_id: project_id,
        success: match?({:ok, _}, result)
      }
    )
  end
end
```

---

## Step 11: Create Mix Tasks

### lib/mix/tasks/pop_stash.project.new.ex

```elixir
defmodule Mix.Tasks.PopStash.Project.New do
  @moduledoc """
  Creates a new PopStash project.

  ## Usage

      mix pop_stash.project.new "My Project Name"
      mix pop_stash.project.new "My Project" --description "Optional description"
  """

  use Mix.Task
  
  @shortdoc "Creates a new PopStash project"

  @impl Mix.Task
  def run(args) do
    Mix.Task.run("app.start")
    
    {opts, args, _} = OptionParser.parse(args, strict: [description: :string])
    
    case args do
      [name] ->
        create_project(name, opts)
      
      [] ->
        Mix.shell().error("Usage: mix pop_stash.project.new \"Project Name\" [--description \"desc\"]")
        
      _ ->
        Mix.shell().error("Too many arguments. Project name should be quoted if it contains spaces.")
    end
  end

  defp create_project(name, opts) do
    case PopStash.Projects.create(name, opts) do
      {:ok, project} ->
        port = Application.get_env(:pop_stash, :mcp_port, 4001)
        
        Mix.shell().info("""
        
        ✓ Created project: #{project.id}
        
        Add to your workspace .claude/mcp_servers.json:
        
        {
          "pop_stash": {
            "url": "http://localhost:#{port}/mcp/#{project.id}"
          }
        }
        """)

      {:error, changeset} ->
        errors = Ecto.Changeset.traverse_errors(changeset, fn {msg, opts} ->
          Regex.replace(~r"%{(\w+)}", msg, fn _, key ->
            opts |> Keyword.get(String.to_existing_atom(key), key) |> to_string()
          end)
        end)
        Mix.shell().error("Failed to create project: #{inspect(errors)}")
    end
  end
end
```

### lib/mix/tasks/pop_stash.project.list.ex

```elixir
defmodule Mix.Tasks.PopStash.Project.List do
  @moduledoc """
  Lists all PopStash projects.

  ## Usage

      mix pop_stash.project.list
  """

  use Mix.Task
  
  @shortdoc "Lists all PopStash projects"

  @impl Mix.Task
  def run(_args) do
    Mix.Task.run("app.start")
    
    projects = PopStash.Projects.list()
    
    if Enum.empty?(projects) do
      Mix.shell().info("No projects found. Create one with: mix pop_stash.project.new \"Project Name\"")
    else
      Mix.shell().info("\nProjects:\n")
      
      for project <- projects do
        age = format_age(project.inserted_at)
        desc = if project.description, do: " - #{project.description}", else: ""
        Mix.shell().info("  #{project.id}  #{project.name}#{desc}  (#{age})")
      end
      
      Mix.shell().info("")
    end
  end

  defp format_age(datetime) do
    diff = DateTime.diff(DateTime.utc_now(), datetime, :second)
    
    cond do
      diff < 60 -> "just now"
      diff < 3600 -> "#{div(diff, 60)} minutes ago"
      diff < 86400 -> "#{div(diff, 3600)} hours ago"
      diff < 604800 -> "#{div(diff, 86400)} days ago"
      true -> "#{div(diff, 604800)} weeks ago"
    end
  end
end
```

### lib/mix/tasks/pop_stash.project.delete.ex

```elixir
defmodule Mix.Tasks.PopStash.Project.Delete do
  @moduledoc """
  Deletes a PopStash project and all associated data.

  ## Usage

      mix pop_stash.project.delete a1b2c3d4-e5f6-7890-abcd-ef1234567890
      mix pop_stash.project.delete a1b2c3d4-e5f6-7890-abcd-ef1234567890 --yes  # Skip confirmation
  """

  use Mix.Task
  
  @shortdoc "Deletes a PopStash project"

  @impl Mix.Task
  def run(args) do
    Mix.Task.run("app.start")
    
    {opts, args, _} = OptionParser.parse(args, strict: [yes: :boolean])
    
    case args do
      [project_id] ->
        delete_project(project_id, opts)
      
      [] ->
        Mix.shell().error("Usage: mix pop_stash.project.delete PROJECT_ID [--yes]")
        
      _ ->
        Mix.shell().error("Too many arguments.")
    end
  end

  defp delete_project(project_id, opts) do
    case PopStash.Projects.get(project_id) do
      {:ok, project} ->
        if opts[:yes] || confirm_delete(project) do
          case PopStash.Projects.delete(project_id) do
            {:ok, _} ->
              Mix.shell().info("✓ Deleted project: #{project_id}")
            {:error, reason} ->
              Mix.shell().error("Failed to delete project: #{inspect(reason)}")
          end
        else
          Mix.shell().info("Cancelled.")
        end

      {:error, :not_found} ->
        Mix.shell().error("Project not found: #{project_id}")
    end
  end

  defp confirm_delete(project) do
    Mix.shell().yes?("""
    
    Are you sure you want to delete project "#{project.name}" (#{project.id})?
    
    This will permanently delete all:
      • Agents
      • Stashes
      • Insights
      • Decisions
      • Locks
      • Sessions
      • Activity logs
    
    Delete this project?
    """)
  end
end
```

---

## Step 12: Create Test Directory Structure

```bash
mkdir -p test/pop_stash/projects
mkdir -p test/support
```

---

## Step 13: Create Test Support Helpers

### test/support/data_case.ex

```elixir
defmodule PopStash.DataCase do
  @moduledoc """
  Test case for tests that require database access.
  """

  use ExUnit.CaseTemplate

  using do
    quote do
      alias PopStash.Repo

      import Ecto
      import Ecto.Changeset
      import Ecto.Query
      import PopStash.DataCase
    end
  end

  setup tags do
    PopStash.DataCase.setup_sandbox(tags)
    :ok
  end

  @doc """
  Sets up the sandbox based on the test tags.
  """
  def setup_sandbox(tags) do
    pid = Ecto.Adapters.SQL.Sandbox.start_owner!(PopStash.Repo, shared: not tags[:async])
    on_exit(fn -> Ecto.Adapters.SQL.Sandbox.stop_owner(pid) end)
  end
end
```

### test/support/fixtures.ex

```elixir
defmodule PopStash.Fixtures do
  @moduledoc """
  Test fixtures for PopStash.
  """

  alias PopStash.Projects

  def project_fixture(attrs \\ %{}) do
    name = Map.get(attrs, :name, "Test Project #{System.unique_integer()}")
    opts = Map.to_list(Map.delete(attrs, :name))
    
    {:ok, project} = Projects.create(name, opts)
    project
  end
end
```

### Update test/test_helper.exs

```elixir
ExUnit.start()

# Start the Ecto sandbox for async tests
Ecto.Adapters.SQL.Sandbox.mode(PopStash.Repo, :manual)
```

---

## Step 15: Create Project Tests

### test/pop_stash/projects_test.exs

```elixir
defmodule PopStash.ProjectsTest do
  use PopStash.DataCase, async: true

  alias PopStash.Projects
  alias PopStash.Projects.Project

  describe "create/2" do
    test "creates a project with auto-generated UUID" do
      assert {:ok, project} = Projects.create("My Project")
      assert project.name == "My Project"
      assert is_binary(project.id)
      # UUID format: 8-4-4-4-12 hex chars
      assert String.match?(project.id, ~r/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)
    end

    test "creates a project with description" do
      assert {:ok, project} = Projects.create("My Project", description: "A test project")
      assert project.description == "A test project"
    end

    test "rejects duplicate project name" do
      {:ok, _} = Projects.create("Duplicate Name")
      assert {:ok, _} = Projects.create("Duplicate Name")  # Names can be duplicated, IDs are unique
    end
  end

  describe "get/1" do
    test "returns project when it exists" do
      {:ok, created} = Projects.create("Test Project")
      assert {:ok, found} = Projects.get(created.id)
      assert found.id == created.id
      assert found.name == "Test Project"
    end

    test "returns error when project doesn't exist" do
      assert {:error, :not_found} = Projects.get(Ecto.UUID.generate())
    end
  end

  describe "list/0" do
    test "returns empty list when no projects" do
      assert [] = Projects.list()
    end

    test "returns projects ordered by creation date (newest first)" do
      {:ok, p1} = Projects.create("First")
      {:ok, p2} = Projects.create("Second")
      {:ok, p3} = Projects.create("Third")

      projects = Projects.list()
      assert length(projects) == 3
      assert [^p3, ^p2, ^p1] = projects
    end
  end

  describe "delete/1" do
    test "deletes existing project" do
      {:ok, project} = Projects.create("To Delete")
      assert {:ok, _} = Projects.delete(project.id)
      assert {:error, :not_found} = Projects.get(project.id)
    end

    test "returns error when project doesn't exist" do
      assert {:error, :not_found} = Projects.delete(Ecto.UUID.generate())
    end
  end

  describe "exists?/1" do
    test "returns true for existing project" do
      {:ok, project} = Projects.create("Exists")
      assert Projects.exists?(project.id)
    end

    test "returns false for non-existing project" do
      refute Projects.exists?(Ecto.UUID.generate())
    end
  end

  defp errors_on(changeset) do
    Ecto.Changeset.traverse_errors(changeset, fn {msg, opts} ->
      Regex.replace(~r"%{(\w+)}", msg, fn _, key ->
        opts |> Keyword.get(String.to_existing_atom(key), key) |> to_string()
      end)
    end)
  end
end
```

---

## Step 15: Update Router Tests

Update `test/pop_stash/mcp/router_test.exs`:

```elixir
defmodule PopStash.MCP.RouterTest do
  use PopStash.DataCase, async: true
  use Plug.Test

  alias PopStash.MCP.Router

  import PopStash.Fixtures

  setup do
    project = project_fixture()
    {:ok, project: project}
  end

  describe "POST /mcp/:project_id" do
    test "handles valid JSON-RPC request", %{project: project} do
      conn =
        conn(:post, "/mcp/#{project.id}", %{
          "jsonrpc" => "2.0",
          "id" => 1,
          "method" => "ping"
        })
        |> put_req_header("content-type", "application/json")
        |> put_private(:remote_ip, {127, 0, 0, 1})
        |> Router.call([])

      assert conn.status == 200
      assert %{"jsonrpc" => "2.0", "id" => 1, "result" => %{}} = Jason.decode!(conn.resp_body)
    end

    test "returns 404 for unknown project" do
      unknown_id = Ecto.UUID.generate()
      conn =
        conn(:post, "/mcp/#{unknown_id}", %{
          "jsonrpc" => "2.0",
          "id" => 1,
          "method" => "ping"
        })
        |> put_req_header("content-type", "application/json")
        |> put_private(:remote_ip, {127, 0, 0, 1})
        |> Router.call([])

      assert conn.status == 404
      response = Jason.decode!(conn.resp_body)
      assert response["error"]["code"] == -32_001
      assert response["error"]["message"] =~ "Project not found"
    end

    test "tools/call ping returns pong", %{project: project} do
      conn =
        conn(:post, "/mcp/#{project.id}", %{
          "jsonrpc" => "2.0",
          "id" => 1,
          "method" => "tools/call",
          "params" => %{"name" => "ping", "arguments" => %{}}
        })
        |> put_req_header("content-type", "application/json")
        |> put_private(:remote_ip, {127, 0, 0, 1})
        |> Router.call([])

      assert conn.status == 200
      response = Jason.decode!(conn.resp_body)
      assert [%{"text" => "pong"}] = response["result"]["content"]
    end
  end

  describe "GET /" do
    test "returns info page with project list" do
      project = project_fixture(name: "Listed Project")
      
      conn =
        conn(:get, "/")
        |> put_private(:remote_ip, {127, 0, 0, 1})
        |> Router.call([])

      assert conn.status == 200
      assert conn.resp_body =~ "PopStash MCP Server"
      assert conn.resp_body =~ project.id
      assert conn.resp_body =~ "Listed Project"
    end
  end

  describe "localhost security" do
    test "rejects non-localhost requests", %{project: project} do
      conn =
        conn(:post, "/mcp/#{project.id}", %{
          "jsonrpc" => "2.0",
          "id" => 1,
          "method" => "ping"
        })
        |> put_req_header("content-type", "application/json")
        |> Map.put(:remote_ip, {192, 168, 1, 100})
        |> Router.call([])

      assert conn.status == 403
    end
  end
end
```

---

## Step 17: Update MCP Server Tests

Update `test/pop_stash/mcp/server_test.exs`:

```elixir
defmodule PopStash.MCP.ServerTest do
  use PopStash.DataCase, async: true

  alias PopStash.MCP.Server
  
  import PopStash.Fixtures

  setup do
    project = project_fixture()
    {:ok, project: project}
  end

  describe "handle_message/2" do
    test "ping returns empty result", %{project: project} do
      message = %{"jsonrpc" => "2.0", "id" => 1, "method" => "ping"}
      assert {:ok, response} = Server.handle_message(message, project)
      assert response.result == %{}
    end

    test "initialize returns server info with project", %{project: project} do
      message = %{
        "jsonrpc" => "2.0",
        "id" => 1,
        "method" => "initialize",
        "params" => %{"protocolVersion" => "2025-03-26"}
      }

      assert {:ok, response} = Server.handle_message(message, project)
      assert response.result.serverInfo.name == "PopStash"
      assert response.result.projectId == project.id
      assert response.result.projectName == project.name
    end

    test "tools/list returns available tools", %{project: project} do
      message = %{"jsonrpc" => "2.0", "id" => 1, "method" => "tools/list"}
      assert {:ok, response} = Server.handle_message(message, project)
      assert is_list(response.result.tools)
      assert Enum.any?(response.result.tools, &(&1.name == "ping"))
    end

    test "tools/call with ping returns pong", %{project: project} do
      message = %{
        "jsonrpc" => "2.0",
        "id" => 1,
        "method" => "tools/call",
        "params" => %{"name" => "ping", "arguments" => %{}}
      }

      assert {:ok, response} = Server.handle_message(message, project)
      assert [%{text: "pong"}] = response.result.content
    end

    test "rejects invalid JSON-RPC", %{project: project} do
      message = %{"invalid" => "request"}
      assert {:error, response} = Server.handle_message(message, project)
      assert response.error.code == -32_600
    end

    test "unknown method returns error", %{project: project} do
      message = %{"jsonrpc" => "2.0", "id" => 1, "method" => "unknown"}
      assert {:error, response} = Server.handle_message(message, project)
      assert response.error.code == -32_601
    end
  end
end
```

---

## Step 18: Verify Implementation

```bash
# Ensure PostgreSQL is running
docker-compose up -d

# Get dependencies
mix deps.get

# Create and migrate database
mix ecto.create
mix ecto.migrate

# Create test database
MIX_ENV=test mix ecto.create
MIX_ENV=test mix ecto.migrate

# Run tests
mix test

# Run static analysis
mix credo

# Start server
mix run --no-halt
```

---

## Step 19: Manual Testing

```bash
# Create a project
mix pop_stash.project.new "My Test Project"
# => Created project: a1b2c3d4-e5f6-7890-abcd-ef1234567890

# List projects
mix pop_stash.project.list
# => a1b2c3d4-e5f6-7890-abcd-ef1234567890  My Test Project  (just now)

# Test with curl (use the project ID from above)
curl -X POST http://localhost:4001/mcp/a1b2c3d4-e5f6-7890-abcd-ef1234567890 \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","id":1,"method":"ping"}'

# Test with unknown project (should fail)
curl -X POST http://localhost:4001/mcp/00000000-0000-0000-0000-000000000000 \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","id":1,"method":"ping"}'
# => {"jsonrpc":"2.0","id":1,"error":{"code":-32001,"message":"Project not found: 00000000-0000-0000-0000-000000000000"...}}

# View info page
open http://localhost:4001
```

---

## Final File Structure

```
pop_stash/
├── config/
│   ├── config.exs        # Updated with ecto_repos
│   ├── dev.exs           # Database config
│   ├── test.exs          # Test database config
│   └── prod.exs          # Production database config
├── docker-compose.yml    # PostgreSQL with pgvector
├── lib/
│   ├── mix/
│   │   └── tasks/
│   │       ├── pop_stash.project.new.ex
│   │       ├── pop_stash.project.list.ex
│   │       └── pop_stash.project.delete.ex
│   └── pop_stash/
│       ├── application.ex    # Updated with Repo
│       ├── repo.ex           # NEW
│       ├── projects.ex       # NEW - context module
│       ├── projects/
│       │   └── project.ex    # NEW - schema
│       └── mcp/
│           ├── router.ex     # Updated - validates project
│           ├── server.ex     # Updated - accepts Project struct
│           └── tools/
│               └── ping.ex
├── priv/
│   └── repo/
│       └── migrations/
│           └── YYYYMMDDHHMMSS_create_projects.exs
├── test/
│   ├── support/
│   │   ├── data_case.ex      # NEW
│   │   └── fixtures.ex       # NEW
│   ├── test_helper.exs       # Updated
│   └── pop_stash/
│       ├── projects_test.exs # NEW
│       └── mcp/
│           ├── router_test.exs   # Updated
│           ├── server_test.exs   # Updated
│           └── tools/
│               └── ping_test.exs
└── mix.exs                   # Updated with Ecto deps
```

---

## Done When

- [ ] `docker-compose up -d` starts PostgreSQL with pgvector
- [ ] `mix ecto.create && mix ecto.migrate` succeeds
- [ ] `mix compile` succeeds with no warnings
- [ ] `mix test` passes all tests
- [ ] `mix credo` passes
- [ ] `mix pop_stash.project.new "Test"` creates a project
- [ ] `mix pop_stash.project.list` shows the project
- [ ] `mix pop_stash.project.delete <uuid> --yes` deletes it
- [ ] `curl` to `/mcp/:project_id` with valid project returns response
- [ ] `curl` to `/mcp/:project_id` with invalid project returns 404 error
- [ ] `http://localhost:4001` shows projects list
- [ ] Initialize response includes `projectId` and `projectName`

---

## Notes

### Why validate project on every request?

1. **Explicit scoping**: Every operation knows exactly which project it belongs to
2. **Error early**: Invalid project IDs fail immediately with helpful error
3. **No hidden state**: Project context is always explicit, never assumed
4. **Simpler tools**: Tools receive project directly, no lookup needed

### pgvector setup

We enable the `vector` extension now even though we won't use it until Phase 4. This ensures:
- The extension is available when needed
- Migration ordering is correct
- No surprises later

### Backward compatibility

The `execute_tool` function checks callback arity to support both:
- `callback.(args)` — Phase 1 tools (like ping)
- `callback.(args, project)` — Phase 1.5+ tools with project awareness

This allows gradual migration of tools without breaking existing ones.